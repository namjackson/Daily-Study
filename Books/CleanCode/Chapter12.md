
# 12장 창발성

## 창발적 설계로 깔끔한 코드를 구현하자
창발성 : 하위 구성요소에는 없는 특성이, 상위계층에서 출현되는 현
상 ( 단순한 결합으로 복잡한 결과를 만들수있다 )

SRP, DIP같은 원칙을 적용하기 쉬워지는 설계 방법

켄트 벡이 제시한 단순한 설계 규칙 네가지 ( **중요도 순서** )
1. 모든 테스트를 실행한다.
2. 중복을 없앤다
3. 프로그래머 의도를 표현한다.
4. 클래스와 메서드 수를 최소로 줄인다

### 단순한 설계 규칙 1: 모든 테스트를 실행하라
- 문서로는 완벽하더라도, 의도대로 돌아가는지 검증할 방법이 필요하다
- 테스트가 불가능한 시스템은 검증도 불가능하기 때문에 출시해서는 안된다.
- 테스트가 가능한 시스템을 만들면, 설계 품질이 높아진다. 
	- SRP - 낮은 결합도, 높은 응집력 
- 테스트 케이스 작성시 설계 품질을 자연스럽게 높일 수 있다.
	- 의존성 주입, 인터페이스, 추상화를 사용하여, 낮은 결합도, 높은 응집력이라는 객체 지향방법론을 지향하는 설계를 할 수 있다.

### 단순한 설계 규칙 2 : 리팩터링
테스트 코드를 모두 작성하면, 코드와 클래스를 정리할 수 있어진다.

코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없기 때문에, 여러 시도를 할 수 있다.
- 응집도 높이기, 결합도 낮추기, 관심사 분리하기, 시스템 관심사로 모듈 나누기, 함수와 클래스 크기 줄이기, 네이밍 변경 등의 기법을 시도하자

#### 중복을 없애라
중복은 추가 작업, 추가 위험, 불필요한 복잡도를 의미한다.
단 몇 줄이라도, 중복을 제거하는 것은 시스템 복잡도를 많이 줄일 수 있다.

```
int size() {}
boolean isEmpty{}
```
 - isEmpty 메소드에서는 size()를 이용하면, 중복된 코드를 줄일 수 있다.

```
boolean isEmpty() {
  return 0 == size();
}
```

TEMPLATE METHOD 패턴은 고차원 중복을 제거할 목적으로 자주 사용되는 기법이다. 
 - 비슷한 두 메소드에서 중복되는 부분을 합치고, 차이가 있는 부분만 별도로 하위 클래스에 작성하는 방법
 - Before
```
public class VacationPolicy {
  public void accrueUSDDivisionVacation() {
    // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드
    // ...
    // 휴가 일수가 미국 최소 법정 일수를 만족하는지 확인하는 코드
    // ...
    // 휴가 일수를 급여 대장에 적용하는 코드
    // ...
  }
  
  public void accrueEUDivisionVacation() {
    // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드
    // ...
    // 휴가 일수가 유럽연합 최소 법정 일수를 만족하는지 확인하는 코드
    // ...
    // 휴가 일수를 급여 대장에 적용하는 코드
    // ...
  }
}
```

- After 
```
abstract public class VacationPolicy {
  public void accrueVacation() {
    caculateBseVacationHours();
    alterForLegalMinimums();
    applyToPayroll();
  }
  
  private void calculateBaseVacationHours() { /* ... */ };
  abstract protected void alterForLegalMinimums();
  private void applyToPayroll() { /* ... */ };
}

public class USVacationPolicy extends VacationPolicy {
  @Override protected void alterForLegalMinimums() {
    // 미국 최소 법정 일수를 사용한다.
  }
}

public class EUVacationPolicy extends VacationPolicy {
  @Override protected void alterForLegalMinimums() {
    // 유럽연합 최소 법정 일수를 사용한다.
  }
}
```


#### 표현하라 
- 내가 이해하는 코드를 짜기는 쉽다. 코드 전체를 이해하기 때문이다. 하지만 시간이 지날수록 코드의 전체를 이해하기는 쉽지 않다.
	- 시스템이 복잡해질수록, 유지보수 개발자는 시스템을 이해하기위해 보내는 시간이 늘어나고, 오해할 가능성이 높아진다.
	- -> 개발자의 의도를 분명히 표현하자! 

1. 기능과 이름이 일치하는 좋은 이름을 선택한다. 
2. 함수와 클래스의 크기를 가능한 줄이자.  
	- 하나의 책임만 있을 수록, 이름 짓기도, 구현하기도, 이해하기도 쉽다.
3. 표준 명칭을 사용한다. 
	- 디자인 패턴은 의사소통과 표현력 강화가 주된 목적이다.
	- 표준 패턴을 사용해 구현된다면 클래스 이름에 패턴 이름을 넣어주면,  다른 개발자들이 이해하기 편해진다.
4. 단위 테스트 케이스를 꼼꼼히 작성한다. 테스트 케이스는 예제로 보여주는 문서이다. 잘만든 테스트 케이스를 읽어 보면, 클래스의 기능을 쉽게 이해할 수 있다.

나중에 읽을 사람을 고려해 조금이라도 읽기 쉽게 만드려는 노력을하자! 

( 대부분의 경우, **나중에 코드를 읽을 사람은 나 자신일 가능성이 크다!** )

#### 클래스와 메서드 수를 최소로 줄여라
중복을 제거하고, 의도를 표현하고, SRP를 준수한다 라는 개념도,  과하면, 실이 많아진다.

클래스와 메소드를 줄이자고, 수많은 클래스와 메소드를 만드는 사례도 있다. 

- 무의미한 클래스와 메서드 수를 최소로 줄이자! 
- 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다.

- 하지만 클래스와 함수 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다

## 결론 
단순한 설계 규칙을 따른다면, 우수한 기법과 원칙을 단번에 활용할수 있다! 

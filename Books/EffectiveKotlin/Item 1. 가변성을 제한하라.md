# Item 1. 가변성을 제한하라
클래스내의 상태값을 가지게 하는 것은 양날의 검이다.
시간의 변화에 따라서, 변화하는 요소를 표현할 수 있다는 것은 유용하지만, 상태를 적절학게 관리하는 것이 생각보다 어렵다

1. 코드를 이해하고, 디버깅하기 어려워진다. 이러한 상태를 갖는 부분들의 관계를 이해하기 어렵고, 추적하기 어려워진다.  
2. 가변성이 있으면, 코드 실행의 추론이 어렵다. 시점에 따라 값이 바뀔수 있다
3. 멀티스레드 환경에서 적절한 동기화 필요하다.
4.모든 상태를 테스트해야되서,  테스트 하기 어렵다. 
5. 상태 변경이 일어날때마다, 관련된 데이터를 새로 정렬해야한다. 

### 코틀린에서 가변성 제한하기
코틀린은 가변성을 제한할 수 있게 설계할수 있다. immutable 객체를 만들거나, 프로퍼티를 변경할 수 없게 막는것이 쉽다

- 읽기 전용 프로퍼티(val)
- 가변 컬렉션과 읽기 전용 컬렉션 구분하기
- 데이터 클래스의 copy

#### 읽기 전용 프로퍼티(val)
val로 선언되는 프로터피는 value처럼 동작하며, 일반적으로 값이 변경되지 않는다. ( 가변값은 var로 선언)
- 읽기 전용 프로퍼티가 변경 불가능한 것은 아니다. val 가 mutable 객체를 담고 있다면, 내부적으로 변할수 있다 ( 읽기전용과 가변성은 다르다.)
- 코틀린의 프로퍼티는 기본적으로 캡슐화 되어 있고, 사용자 정의 접근자 getter, setter를 가질수 있다. var : getter, setter / val : getter 만 제공된다. (val을 var로 오버라이드 할수 있다. )
- val은 읽기 전용 프로퍼티지만, 불변은 아니다. 게터, 델릭게이트로 정의할수 있다. ( 변경할 필요가 없다면, final 프로퍼티 사용하는게 좋다)

#### 가변 컬렉션과 읽기 전용 컬렉션 구분하기
Iterable, Collection, Set, List 인터페이스는 읽기 전용 컬렉션이고, MutableIterable, MutableCollection, MutableSet, MutableList는 읽고,쓰기 가능한 컬렉션이다. 
![](Item%201.%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%A6%E1%84%92%E1%85%A1%E1%86%AB%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1/586278EC-0A04-4C49-829F-DAFD9BB6E950.png)
- 읽기 전용 컬렉션의 내부의 값을 변경할 수 없진 않다. 대부분의 경우 변경 인터페이스가 지원하지 않는다.
- 내부적으로 mutable 컬렉션이라도, 외부에 immutable하게 보이게 하여 안정성을 높일수 있다.
- -> 다운캐스팅으로 immutable 컬렉션도 mutable으로 변경할수있지만, 추상화를 무시하는 코드로 안정성을 보장할수 없다. ( 실제 내부 컬렉션이 mutable임을 보장하지 않기때문에)
- 다운캐스팅 보다는 copy를 통해 새로운 mutable 컬렉션을 만들어서 활용할것

#### 데이터 클래스의 Copy

Immutable 객체 장점
- 한번 정의된 상태가 변경되지 않음으로, 코드 이해하기가 쉽다.
- 불변 객체를 공유해도, 충돌나지 않기 때문에, 병렬처리도 안전하다.
- 객체에 대한 참조는 변경되지 않아서, 쉽게 캐시 가능하다.
- 불변객체는 방어적 복사를 사용할 필요 없다.
- 다른 개체 생성시, 활용하기 좋다. 불변객체는 예측가능하기 때문에
- set,map 컬렉션의 키로 사용할수 있다.

Immutable의 단점으로는 객체를 변경할수 없지만,

변경 대신 새로운 객체를 생성하도록 해야한다. 
`fun withSurname(surname: String) = User(name, surname)`
( surname 프로퍼티의 변경이 아닌, 변경된 값을 가진 새로운 객체 생성) 

모든 프로퍼티에 대한 함수를 정의하기 어려우니 dataClass의 copy 활용
`user = user.copy(usrname = “Jo”)`


### 다른 종류의 변경 가능 지점
변경할수 있는 리스트 2가지 방법이 있음
```kotlin 
// 불변 프로퍼티에 가변컬렉션
val list1: MutableList<Int> = mutableListOf()

// 가변 프로퍼티에 불변컬렉션
var list2: List<Int> = listOf()
```

두 리스트 모두 변경이 가능하지만. 각각의 장단점이 존재

변경 가능 지점이 다름
- list1 `val list1: MutableList<Int> = mutableListOf() `
	- 리스트 구현 내부에 변경 가능 지점이 있음
	- 멀티쓰레드 환경에서 적절한 동기화 처리에 대한 안정성이 없음.
- list2  `var list2: List<Int> = listOf()`
	- 멀티쓰레드 처리의 안정성이 좋다. ( 잘못만들 경우, 몇몇 요소가 소실될수 있음)
	- 사용자 정의 세터, 델리게이트를 활용하여 변경 추적이 가능하다.

#### 변경 가능 지점 노출하기 말기
Mutable 객체를 외부에 노출하면 위험하다.
이를 방지하는 두가지 방법이 있다.
1. 방어적 복사 : data 클래스의 copy활용
 
```kotlin
class UserHoloder {
	private val user: MutableUser()
	fun get(): MutableUser(){
		return user.copy()
	}
}
```

2. 가변성을 제한하는 방식 : 읽기 전용 슈퍼 타입으로 업캐스팅하여 가변성 제어
```kotlin
private val storedUsers: MutableMap<Int, String> = mutableMapOf()
fun loadAll(): MutableMap<Int, String> {
    return storedUsers
}
```

### 정리
가변성을 제한한 immutable 객체를 사용하면 많은 장점이 있다. 가변 지점을 제어하기 위해 kotlin의 도구를 활용할수 있다.
- var 보다는 val을 지향
- 	mutable 프로퍼티보다는 immutable 프로퍼티를 지향
* mutable 객체와 클래스보다는 immutable 객체와 클래스를 사용하는 것이 좋음
* 변경이 필요한 대상을 만들어야 한다면, immutable 데이터 클래스로 만들고 copy를 활용하는 것이 좋음
* 컬렉션에 상태를 저장해야 한다변, mutable 컬렉션보다는 읽기 전용 컬렉션을 사용하는 것이 좋음
* 변이 지점을 적절하게 설계하고, 불필요한 변이 지점은 만들지 않는 것이 좋음
* mutable 객체를 외부에 노출하지 않는 것이 좋음

#### 내 생각
- 함수형 프로그래밍의 기본인 불변성에 대한 설명과, 활용학기 위한 방법을 소개해주었다.
- 이를 기본으로 코드를 작성하면 좀 더 안전한 코드 및 함수형스럽게 할수있는 기반이 될거 같다.
